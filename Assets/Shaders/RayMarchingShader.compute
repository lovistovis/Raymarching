// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "noiseSimplex.cginc"


static const float PI = 3.14159265;
RWStructuredBuffer<float> LoseBuffer;
RWTexture2D<float4> RenderTexture;
int2 Resolution;
int FunctionNum;
int ColorNum;
float3 CameraPosition;
float Time;
float Scale;
float ColorModifier;
float Bounds;
float MinDist;
int Iterations;
bool AlwaysShowFinalColor;
float4x4 CameraToWorld;
float4x4 CameraInverseProjection;


float smoothMin(float dstA, float dstB, float k)
{
    float h = max(k-abs(dstA-dstB), 0) / k;
    return min(dstA, dstB) - h*h*h*k*1/6.0;
}

float3 convertRgbToHsl(float3 c) { 
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); 
    float4 p = lerp(float4(c.yz, K.wz), float4(c.yz, K.xy), step(c.z, c.y)); 
    float4 q = lerp(float4(p.xyw, c.r), float4(c.x, p.yzx), step(p.x, c.x)); 
    
    float d = q.x - min(q.w, q.y); 
    float e = 1.0 * pow(10, -10); 
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); 
} 

float3 convertHslToRgb(float3 c) { 
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); 
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www); 
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float3 DirectionOfRayForPixel(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(CameraToWorld, float4(0.0, 0.0, 0.0, 1.0)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(CameraInverseProjection, float4(uv, 0.0, 1.0)).xyz;

    // Transform the direction from camera to world space and normalize
    direction = mul(CameraToWorld, float4(direction, 0.0)).xyz;
    direction = normalize(direction);

    return direction;
}

float SignedDistanceFromMandelBulbOld(float3 p) {
	float3 z = p;
	float dr = 1.0;
	float r = 0.0;//d
    float Power = 8.0;

	for (int i = 0; i < 100; i++) {
		r = length(z);
		if (r > 4) break;
		
		// convert to polar coordinates
		float theta = acos(z.z/r);
		float phi = atan(z.y / z.x);
		dr = pow( r, Power-1.0)*Power*dr + 1.0;
		
		// scale and rotate the point
		float zr = pow(r, Power);
		theta = theta*Power;
		phi = phi*Power;
		
		// convert back to cartesian coordinates
		z = zr * float3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z += p;
	}
	return 0.5*log(r)*r/dr;
}

float SignedDistanceFromMandelBulb(float3 p, float time) {
	float3 z = p;
	float dr = 1.0;
	float r = 0.0;//d
    float Power = time;

	for (int i = 0; i < 30; i++) {
		r = length(z);
		if (r > 4) { break; }
		
		// convert to polar coordinates
		float theta = acos(z.z / r);
		float phi = atan(z.y / z.x);
		dr = pow(r, Power - 1.0) * Power * dr + 1.0;
		
		// scale and rotate the point
		float zr = pow(r, Power);
		theta = theta * Power;
		phi = phi * Power;
		
		// convert back to cartesian coordinates
		z = zr * float3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
		z += p;
	}
	return 0.5*log(r)*r/dr;
}

float SignedDistanceSebastianNice1(float3 p, float time)
{
    float dstA = dot(sin(p * time / p.z * p.x), 1);
    float dstB = cross(pow(abs(p.y%1000), time / 10), 1);
    return lerp(dstA, dstB, 0.5);
}

float SignedDistanceSebastian(float3 p, float time)
{
    float dstA = dot(sin(p * time * pow(smoothMin(p.y, p.x, 1.0), 2)), 1);
    float dstB = dot(pow(abs(p%1000), time / 5) * p.z*p.y*p.x*time, 1) /(p.x/(time));
    return lerp(dstA, dstB, 0.5);
}

float SignedDistanceSebastian2(float3 p, float time)
{
    float dstA = dot(sin(p * time / p.z * p.x), 1);
    float dstB = cross(pow(abs(p.y%1000), time / 10), 1);
    return lerp(dstA, dstB, 0.5);
}

float SignedDistanceNoise(float3 p, float time)
{
    return snoise(p * 0.16 * sin(time / 100)) + 1 - abs(sin(time / 10)); // sin(time / 10);
}

float SignedDistanceNoiseLandscape(float3 p, float time)
{
    float3 rounded = float3(floor(p.x / 10) * 10, floor(p.y / 10) * 10, floor(p.z / 10) * 10);
    return min(p.y - p.x, snoise(float3(rounded.x, time, rounded.z)) * 10 + p.y) /* + snoise(rounded / 70) * 100 + snoise(rounded / 7) * 10 + snoise(rounded)*/;
}

float SignedDistanceTest(float3 p, float time)
{
    return snoise(p.x*p.y / 100 * float3(1.0, 1.0, 1.0)) - abs(sin(time/10));
}

float SignedDistanceTest1(float3 p, float time)
{
    return pow(p.x*p.z/p.y, time);
}

float SignedDistanceLissajous(float3 p, float time)
{
    float a = 1.0 + 0.5 * sin(time);
    float b = 1.0 + 0.5 * cos(time);
    float x = a * sin(3.0 * p.y + time);
    float y = b * sin(2.0 * p.x - time);
    return length(float2(p.x - x, p.y - y)) - 0.1;
}

float SignedDistanceFractalTwist(float3 p, float time)
{
    float twist = sin(time + length(p.xy)) * 0.5;
    p.xy = mul(p.xy, float2x2(cos(twist), sin(twist), -sin(twist), cos(twist)));
    return length(p) - 1.0 + sin(dot(p, p * time * 0.1)) * 0.3;
}

float SignedDistanceMorphingPyramid(float3 p, float time)
{
    float height = 1.0 + 0.5 * sin(time);
    float base = 1.0 + 0.2 * cos(time);
    float d = max(p.y - height, max(abs(p.x) + abs(p.z) - base, 0.0));
    return d;
}

float SignedDistanceSineWarpChaos(float3 p, float time)
{
    float dstA = sin(dot(p, p) * time * 0.1);
    float dstB = cos(length(p) + time * 2.0);
    return abs(dstA * dstB * p.x + p.y) / (sin(time * 0.5) + 0.1);
}

float SignedDistanceHyperbolicSpiral(float3 p, float time)
{
    float spiral = sin(p.x + time) * cos(p.y - time);
    float dst = length(p) - (spiral * 0.5 + 1.0);
    return abs(dst * cos(time + p.x * p.y)) + sin(dot(p.xy, p.xy) + time);
}

float SignedDistanceNoiseFusedSphere(float3 p, float time)
{
    float r = length(p) + sin(time + dot(p, p) * 0.1);
    float noise = frac(sin(dot(p.xy, float2(12.9898, 78.233))) * 43758.5453);
    return r - (0.5 + noise * 0.5);
}

float SignedDistanceRandomFieldWarp(float3 p, float time)
{
    float warp = frac(sin(dot(p.xy, float2(12.9898, 78.233))) * 43758.5453);
    float dst = length(p) + warp * time;
    return dst - (sin(time + dot(p, p)) * 0.5);
}

float SignedDistanceComplexCrossChaos(float3 p, float time)
{
    float dstA = dot(p, sin(p * time * 0.1));
    float dstB = cross(float3(abs(p.y), abs(p.z), abs(p.x)), float3(time, p.x, p.y)).x;
    return sin(dstA * dstB) * 0.5;
}

float SignedDistanceCoolEffect(float3 p, float time)
{
    // Warp space with sin and time to get chaotic movement
    float3 q = p * sin(time * 0.5) + cos(p * time * 0.2);
    
    // Layer 1: Use a sine and time warp to create a wave-like distortion
    float dstA = dot(sin(q * time / q.z * q.x), 1.0);

    // Layer 2: Use a cross product with fract and mod to create wild patterns
    float3 r = float3(
        pow(abs(frac(p.y * sin(time))), time * 0.1), 
        fmod(p.x * p.z * cos(time * 0.3), 50), 
        abs(p.z * sin(time))
    );
    float dstB = dot(cross(r, q), 1.0);

    // Layer 3: Combine with a smoothstep for blending between layers
    float blendFactor = smoothstep(0.1, 0.9, sin(time * 0.5));
    
    // Final distance: blending dstA and dstB with some dynamic chaos
    return lerp(dstA, dstB, blendFactor);
}

float SignedDistnaceFractal(float3 p, float time)
{
    // Initialize parameters
    float scale = 2.0; // Scaling factor
    float offset = 1.0; // Offset to add between iterations
    float dist = 0.0; // Final distance value
    int iterations = 5; // Number of fractal iterations

    // Fractal iteration loop
    for (int i = 0; i < iterations; i++)
    {
        // Warp the space with time and sin for chaotic fractal behavior
        p = abs(p) - offset; // Mirror the space around the origin
        p = p * scale + sin(time + p * 0.5); // Scale and warp the space with sin

        // Distance calculation, this could be for a sphere-like shape
        dist += length(p) / pow(scale, float(i)); // Accumulate the distance
    }

    return dist; // Return the fractal distance
}

float SignedDistanceFromSphere(float3 p, float3 spherePosition, float radius)
{
    return length(p - spherePosition) - radius;
}

float SignedDistanceInfiniteSphereLattice(float3 p, float spacing, float offset, float radius) {
    p = p - offset;
    float3 nearestCenter = round(p / spacing) * spacing;
    float3 localP = p - nearestCenter;
    return SignedDistanceFromSphere(localP, float3(0.0, 0.0, 0.0), radius);
}

float SignedDistanceMandelbulbAI(float3 p, float time)
{
    // Initialize constants for the Mandelbulb fractal
    const int iterations = 8;      // Number of iterations for fractal recursion
    const float power = 8.0;       // Power used in the Mandelbulb formula
    const float bailout = 8.0;     // Escape radius
    const float scale = 1.2;       // Scale factor to control size

    // Initialize variables
    float3 z = p;                  // Position in 3D space
    float dr = 1.0;                // Derivative of the distance function
    float r = 0.0;                 // Magnitude of the point
    
    // Mandelbulb iteration loop
    for (int i = 0; i < iterations; i++)
    {
        // Calculate the distance from the origin
        r = length(z);
        if (r > bailout) break;    // If the point escapes, break the loop
        
        // Convert the point z to spherical coordinates
        float theta = acos(z.z / r);            // Polar angle
        float phi = atan2(z.y, z.x);            // Azimuthal angle
        
        // Mandelbulb power transformations in spherical coordinates
        float zr = pow(r, power - 1.0);         // Magnitude raised to (power - 1)
        dr = dr * power * zr + 1.0;             // Derivative accumulation
        
        // Rotate and stretch the point using Mandelbulb formula
        float newR = pow(r, power);             // New radius
        theta = theta * power;                  // Polar angle scaled by power
        phi = phi * power;                      // Azimuthal angle scaled by power
        
        // Convert back to Cartesian coordinates
        z = newR * float3(
            sin(theta) * cos(phi),              // x coordinate
            sin(phi) * sin(theta),              // y coordinate
            cos(theta)                          // z coordinate
        ) + p;                                  // Add original point
        
        // Apply time-dependent transformation for dynamic effect
        z += sin(time * 0.1 + z * scale);       // Time-warped displacement
    }
    
    // Final distance estimation using the fractal escape formula
    return 0.5 * log(r) * r / dr;
}

void sphereFold(inout float3 z, inout float dz) {
    float minRadius2 = 1.0;
    float fixedRadius2 = 100.0;
	float r2 = dot(z, z);
	if (r2 < minRadius2) { 
		// linear inner scaling
		float temp = (fixedRadius2 / minRadius2);
		z *= temp;
		dz *= temp;
	} else if (r2 < fixedRadius2) { 
		// this is the actual sphere inversion
		float temp = (fixedRadius2 / r2);
		z *= temp;
		dz *= temp;
	}
}

void boxFold(inout float3 z, inout float dz) {
    float foldingLimit = 0.5;
	z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;
}

float SignedDistanceMandelBox(float3 z, float time)
{
	float3 offset = z;
	float dr = 1.0;
    float scale = 1.5;
	for (int n = 0; n < 100; n++) {
		boxFold(z, dr);       // Reflect
		sphereFold(z, dr);    // Sphere Inversion
 		
        z = scale * z + offset;  // Scale & Translate
        dr = dr * abs(scale) + 1.0;
	}
	float r = length(z);
	return r / abs(dr);
}

float potential(in float3 pos)
{
	float3 z = pos;
	for(int i = 1; i < 4.0; i++) return log(length(z))/pow(Time,float(i));
	return 0.0;	
}

float SignedDistanceMandelBox2(float3 p, float time) {
	float pot = potential(p);
    float EPS = 10.0;
    float3 xDir = float3(1.0, 0.0, 0.0);
    float3 yDir = float3(0.0, 1.0, 0.0);
    float3 zDir = float3(0.0, 0.0, 1.0);
	if (pot == 0.0) return 0.0;
	float3 gradient = (float3(potential(p+xDir*EPS), potential(p+yDir*EPS), potential(p+zDir*EPS))-pot)/EPS;
	return (0.5/exp(pot))*sinh(pot)/length(gradient);
}

float SignedDistanceFromScene(float3 p, float time)
{
    switch (FunctionNum)
    {
        case 0:
            return SignedDistanceSebastian(p, time); //min(p.z, min(p.x, min(p.y, SignedDistanceFromSphere(p, float3(0.3, 0.0, 0.4), 0.3) ) ) );
        case 1:
            return SignedDistanceSebastianNice1(p, time);
        case 2:
            return SignedDistanceNoise(p, time);
        case 3:
            return smoothMin(SignedDistanceNoise(p, time * 100.0), SignedDistanceSebastianNice1(p, time), 0.5);
        case 4:
            return SignedDistanceCoolEffect(p, time);
        case 5:
            return SignedDistnaceFractal(p, time);
        case 6:
            return SignedDistanceInfiniteSphereLattice(p, 100.0, 1.0, time);
        case 7:
            return SignedDistanceFromMandelBulb(p, time);
        case 8:
            return SignedDistanceMandelBox2(p, time);
        default:
            return 0.0;
    }
}

float3 RayColor(float3 rayPosition, bool notFound, float3 normal, float depth, float time, float colorModifier)
{
    float3 lightPos;
    float dotSN;
    float grayscale;
    float part;
    float3 color;
    if (!AlwaysShowFinalColor && notFound) {
        switch (ColorNum) {
            case 1:
                return float3(1.0, 1.0, 1.0);
            default:
                return float3(0.0, 0.5, 0.0);
        }
    }
    switch (ColorNum)
    {
        case 0:
            return float3(0.5 + 0.5 * normal);
        case 1:
            grayscale = depth / 5000.0;
            return float3(grayscale, grayscale, grayscale);
        case 2:
            return normal;
        case 3:
            lightPos = CameraPosition;
            dotSN = lerp(abs(snoise(rayPosition.xyz)), dot(normal, normalize(lightPos - rayPosition)), 1.0);
            return float3(0.5+0.5*normal) * dotSN;
        case 4:
            lightPos = CameraPosition;
            dotSN = lerp(abs(snoise(rayPosition.xyz)), dot(normal, normalize(lightPos - rayPosition)), 1.0);
            color = float3(0.5 + 0.5 * normal) * dotSN;
            return convertHslToRgb(convertRgbToHsl(color) + float3(sin((time / 3) + 1) / 2, 0, 0));
        case 5:
            return float3(sin(rayPosition.x), tan(rayPosition.y), cos(rayPosition.z));
        case 6:
            return float3(sin(rayPosition.x), 0.0, cos(rayPosition.z));
        case 7:
            return float3(sin(tan(rayPosition.x)), cos(rayPosition.y), cos(rayPosition.z));
        case 8:
            return float3(sin(rayPosition.x) * normal.x, cos(rayPosition.y) * normal.y, cos(rayPosition.z) * normal.z);
        case 9:
            return float3(sin(rayPosition.x) * cos(normal.x), cos(rayPosition.y) * tan(normal.y), cos(rayPosition.z) * sin(normal.z));
        case 10:
            lightPos = CameraPosition;
            dotSN = lerp(abs(snoise(rayPosition.xyz)), dot(normal, normalize(lightPos - rayPosition * rayPosition)), sin(time));
            color = float3(0.5 + 0.5 * normal) * dotSN;
            return convertHslToRgb(convertRgbToHsl(color) + float3(sin((time / 3) + 1) / 2, 0, 0));
        case 11:
            grayscale = 0.5 + sin(normal.x) * 0.5;
            return float3(grayscale, grayscale, grayscale);
        case 12:
            grayscale = 0.5 + sin(normal.y) * 0.5;
            return float3(grayscale, grayscale, grayscale);
        case 13:
            grayscale = 0.5 + sin(normal.z) * 0.5;
            return float3(grayscale, grayscale, grayscale);
        case 14:
            part = 0.5 / 1.5;
            grayscale = 0.5 + sin(normal.x) * part + sin(normal.y) * part + sin(normal.z) * part;
            return float3(grayscale, grayscale, grayscale);
        case 15:
            part = 0.5 / 1.5;
            grayscale = 0.5 + sin(normal.x) * part + sin(normal.y) * part + sin(normal.z) * part;
            return float3(sin(grayscale * 100.0), cos(grayscale * 50.0), sin(grayscale * 10.0));
        case 16:
            part = 0.5 / 1.5;
            grayscale = 0.5 + sin(normal.x) * part + sin(normal.y) * part + sin(normal.z) * part;
            float3 color1 = float3(sin(grayscale * 100.0), cos(grayscale * 50.0), sin(grayscale * 10.0));
            float3 color2 = float3(grayscale, grayscale, grayscale);
            return lerp(color1, color2, sin(normal.x * 100.0));
        case 17:
            part = 0.5 / 1.5;
            grayscale = 0.5 + sin(normal.x) * part + sin(normal.y) * part + sin(normal.z) * part;
            return convertHslToRgb(float3(sin(grayscale), cos(grayscale), sin(grayscale * grayscale)));
        case 18:
            return convertHslToRgb(float3(sin(normal.x), cos(normal.y), sin(normal.z)));
        case 19:
            return convertHslToRgb(float3(normal.x, normal.y, normal.z));
        default:
            return float3(0.5, 0.5, 0);
    }
}

float3 estimateNormal(float3 p, float time)
{
    float EPS = 0.001;
    float xPl = SignedDistanceFromScene(float3(p.x + EPS, p.y      , p.z      ), time );
    float xMi = SignedDistanceFromScene(float3(p.x - EPS, p.y      , p.z      ), time );
    float yPl = SignedDistanceFromScene(float3(p.x      , p.y + EPS, p.z      ), time );
    float yMi = SignedDistanceFromScene(float3(p.x      , p.y - EPS, p.z      ), time );
    float zPl = SignedDistanceFromScene(float3(p.x      , p.y      , p.z + EPS), time );
    float zMi = SignedDistanceFromScene(float3(p.x      , p.y      , p.z - EPS), time );

    float xDiff = xPl - xMi;
    float yDiff = yPl - yMi;
    float zDiff = zPl - zMi;

    return normalize(float3(xDiff, yDiff, zDiff));
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // If outside texture return
    if (id.x < 0 || id.x > (uint)Resolution.x || id.y < 0 || id.y > (uint)Resolution.y) { return; }

    if (id.x == 0 && id.y == 0)
    {
        if (SignedDistanceFromScene(CameraPosition, Time) < 0)
        {
            LoseBuffer[0] = 1;
        }
    }

    float2 uv = float2((id.xy + float2(0.5, 0.5)) / Resolution.xy * 2.0 - 1.0);

    float3 rayDirection = DirectionOfRayForPixel(uv) * Scale;

    bool notFound = false;
    float3 rayPosition = CameraPosition;
    for (int i = 0; i <= Iterations; i++)
    {
        float distance = SignedDistanceFromScene(rayPosition, Time);

        if (distance < MinDist) { break; }

        // Move ray to radius of circle
        rayPosition += rayDirection * distance;

        if (i == Iterations || length(rayPosition - CameraPosition) > Bounds) { notFound = true; break; }
    }

    float depth = abs(length(rayPosition - CameraPosition));
    float3 normal = estimateNormal(rayPosition, Time);

    float3 color = RayColor(rayPosition, notFound, normal, depth, Time, ColorModifier);

    RenderTexture[id.xy] = float4(color.xyz, 1.0);
}
